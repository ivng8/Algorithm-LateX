\documentclass[11pt]{article}

\newcommand{\yourname}{Ivan Ng}
\newcommand{\yourcollaborators}{N/A}

\def\comments{0}

%format and packages

%\usepackage{algorithm, algorithmic}

\usepackage{ulem}
\usepackage{epsfig, graphicx}
\usepackage[noend]{algpseudocode}
\algnewcommand{\LineComment}[1]{\State \(\triangleright\) #1}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{framed}
\usepackage{verbatim}
\usepackage[margin=1.1in]{geometry}
\usepackage{microtype}
\usepackage{kpfonts}
\usepackage{palatino}
	\DeclareMathAlphabet{\mathtt}{OT1}{cmtt}{m}{n}
	\SetMathAlphabet{\mathtt}{bold}{OT1}{cmtt}{bx}{n}
	\DeclareMathAlphabet{\mathsf}{OT1}{cmss}{m}{n}
	\SetMathAlphabet{\mathsf}{bold}{OT1}{cmss}{bx}{n}
	\renewcommand*\ttdefault{cmtt}
	\renewcommand*\sfdefault{cmss}
	\renewcommand{\baselinestretch}{1.05}
\usepackage[usenames,dvipsnames]{xcolor}
\definecolor{DarkGreen}{rgb}{0.15,0.5,0.15}
\definecolor{DarkRed}{rgb}{0.6,0.2,0.2}
\definecolor{DarkBlue}{rgb}{0.2,0.2,0.6}
\definecolor{DarkPurple}{rgb}{0.4,0.2,0.4}
\usepackage{listings}
\usepackage[pdftex]{hyperref}
\hypersetup{
	linktocpage=true,
	colorlinks=true,				% false: boxed links; true: colored links
	linkcolor=DarkBlue,		% color of internal links
	citecolor=DarkBlue,	% color of links to bibliography
	urlcolor=DarkBlue,		% color of external links
}
\usepackage{tcolorbox}


%enclosure macros
\newcommand{\paren}[1]{\ensuremath{\left( {#1} \right)}}
\newcommand{\bracket}[1]{\ensuremath{\left\{ {#1} \right\}}}
\renewcommand{\sb}[1]{\ensuremath{\left[ {#1} \right\]}}
\newcommand{\ab}[1]{\ensuremath{\left\langle {#1} \right\rangle}}

%probability macros
\newcommand{\ex}[2]{{\ifx&#1& \mathbb{E} \else \underset{#1}{\mathbb{E}} \fi \left[#2\right]}}
\newcommand{\pr}[2]{{\ifx&#1& \mathbb{P} \else \underset{#1}{\mathbb{P}} \fi \left[#2\right]}}
\newcommand{\var}[2]{{\ifx&#1& \mathrm{Var} \else \underset{#1}{\mathrm{Var}} \fi \left[#2\right]}}

%useful CS macros
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\polylog}{\mathrm{polylog}}
\newcommand{\zo}{\{0,1\}}
\newcommand{\pmo}{\{\pm1\}}
\newcommand{\getsr}{\gets_{\mbox{\tiny R}}}
\newcommand{\card}[1]{\left| #1 \right|}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\negl}{\mathrm{negl}}
\newcommand{\eps}{\varepsilon}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand{\eqand}{\qquad \textrm{and} \qquad}
\newcommand{\ind}[1]{\mathbb{I}\{#1\}}
\newcommand{\sslash}{\ensuremath{\mathbin{/\mkern-3mu/}}}

%info theory macros
\newcommand{\SD}{\mathit{SD}}
\newcommand{\sd}[2]{\SD\left( #1 , #2 \right)}
\newcommand{\KL}{\mathit{KL}}
\newcommand{\kl}[2]{\KL\left(#1 \| #2 \right)}
\newcommand{\CS}{\ensuremath{\chi^2}}
\newcommand{\cs}[2]{\CS\left(#1 \| #2 \right)}
\newcommand{\MI}{\mathit{I}}
\newcommand{\mi}[2]{\MI\left(~#1~;~#2~\right)}

%mathbb
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
%mathcal
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\cV}{\mathcal{V}}
\newcommand{\cW}{\mathcal{W}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cY}{\mathcal{Y}}
\newcommand{\cZ}{\mathcal{Z}}

\newcommand{\hs}{\hspace{0.2in}}
%theorem macros
\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{fact}[thm]{Fact}
\newtheorem{clm}[thm]{Claim}
\newtheorem{rem}[thm]{Remark}
\newtheorem{coro}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{conj}[thm]{Conjecture}
	\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}

\theoremstyle{theorem}
\newtheorem{prob}{Problem}

\newcommand{\opt}{\mbox{{\sc Opt}}}

\newcommand{\course}{CS 3000: Algorithms \& Data}
\newcommand{\semester}{Spring 2024}

\newcommand{\hwnum}{4}
\newcommand{\hwdue}{Sunday March 3 at 11:59pm via Gradescope}

\newif\ifsolution

\solutiontrue
%\solutionfalse
\ifsolution
\newcommand{\solution}[1]{{\medskip\noindent\color{DarkBlue}\textbf{Solution:} {#1}}}
\else
\newcommand{\solution}[1]{}
\fi

\begin{document}
{\Large 
\begin{center} \course\ --- \semester\ \end{center}}
{\large
\vspace{10pt}
\noindent Homework~\hwnum \vspace{2pt}\\
Due~\hwdue}

\vspace{15pt}
\bigskip
{\large
\noindent Name: \yourname \vspace{2pt}\\ Collaborators: \yourcollaborators}

\vspace{15pt}
\begin{itemize}

\item
  Make sure to put your name on the first page.  If you are using the
  \LaTeX~template we provided, then you can make sure it appears by
  filling in the \texttt{yourname} command.

\item This homework is due~\hwdue.  No late assignments will be accepted.  Make sure to submit something before the deadline.

\item Solutions must be typeset in \LaTeX.  If you need to draw any diagrams,
  you may draw them by hand as long as they are embedded in the PDF.
  We recommend that you use the source file for this assignment to get started, which can be accessed from \href{https://www.overleaf.com/read/jypqtzqttwmn#ba02b5}{this} link.

\item We encourage you to work with your classmates on the homework
  problems, but also urge you to attempt all of the problems by
  yourself first. \emph{If you do collaborate, you must write all
    solutions by yourself, in your own words.}  Do not submit anything
  you cannot explain.  Please list all your collaborators in your
  solution for each problem by filling in the
  \texttt{yourcollaborators} command.

\item Finding solutions to homework problems on the web, or by asking
  students not enrolled in the class is strictly forbidden.

\end{itemize}
\newpage

\begin{prob}
	(25 points) Coloring Maps
\end{prob}

Consider a two dimensional map decomposed into a number of regions. Suppose that each region shares borders with at most $d$ other regions. Prove that having $d+1$ colors suffices to assign one color to each region such that any two regions that share a border receive different colors. 

The figure below shows a map and a valid coloring of it that uses 4 colors.

\begin{figure}[h]
\centering
    \includegraphics[scale=0.2]{figs/Four_Colour_Map_Example.svg.png}
\end{figure}

\textbf{Remark:} The problem above is an easier version of the 4 coloring problem, which states that each such map can be colored with 4 colors even if $d$ is much larger than 3. 
\newpage
In a map of several regions if each region shares borders with at most $d$ other regions, having $d + 1$ colors will suffice to assign a color to each region such that any two regions that share a border have different colors. \\\\
\textbf{Inductive Hypothesis:} Let $H(n)$ be the statement that for $n$ regions the statement above holds true. We will prove that $H(n)$ holds true for $n \ge 1$. \\\\
\textbf{Base Case:} $n = 1$ \\
There is one region that shares no borders with other regions, therefore $2$ colors will suffice. \\\\
\textbf{Inductive Step:} We will now show that for every $n \ge 2, H(n) \rightarrow H(n - 1)$. Assume the hypothesis holds. Now we can represent the map as a graph where every region is a vertex $v$ and the edges they have represent the borders they share with other regions. Since the hypothesis is assumed to be held, every $v$ can have at most $n$ edges which with $n + 1$ colors means that there will be enough colors to be distributed among $v$ and $n$ vertices. Now suppose we remove $v$ from the graph thus lowering the $n$ to $n - 1$. By hypothesis, this graph can be colored with $n + 1 - 1 = n$ colors. Therefore, by induction, this statement holds for all subgraphs until ultimately reaching the base case, for all $n \ge 2$.


\newpage

\begin{prob}
    (25 points) Currency Exchange
\end{prob}


Suppose you are a cashier and have unlimited supply of coins of values \$1, \$5, \$10, \$25, and \$100. Given an amount $n$ in the input, your task is to pay $n$ with as few coins as possible. The {\em Cashier Exchange} algorithm is a greedy algorithm for this task that works as follows:

    \begin{tcolorbox}
    \textbf{The Cashier Exchange Algorithm}
    
    \begin{itemize}
        \item $\texttt{coinset} \gets \emptyset$, $\texttt{coinsum} \gets 0$
        \item While $S < n$:
            \begin{itemize}
                \item Pick the largest coin $c \in \{\$1, \$5, \$10, \$25, \$100\}$ such that $c + \texttt{coinsum} \leq n$.
                \item $\texttt{coinset} \gets \texttt{coinset} \cup \{c \}$
                \item $\texttt{coinsum} \gets \texttt{coinsum} + c$
            \end{itemize}
        \item Return \texttt{coinset}.
    \end{itemize}
    \end{tcolorbox}

    \begin{enumerate}
        \item \textbf{(15 Points)} Prove that the cashier exchange algorithm correctly returns the minimum number of coins to pay $n$ for any given $n \geq 1$. \\\\
        \textbf{Correctness:} By ensuring that the running summing $coinsum$ added to the newest coin $c$ will be less than or equal to the target $n$, this guarantees that the $coinset$ won't ever exceed the target $n$. With the $1$ coin making it possible to amount to all integers, These $2$ axioms guarantee that the $coinsum$ will always reach exactly $n$ before terminating. \\\\
        \textbf{Optimality:} Let's say you have two sets (the optimal set and the greedy set) \\ If we assume the greedy algorithm is incorrect there must be some coin in the optimal set that was replaced by a combination of coins in the greedy set. Since the greedy algorithm chooses the largest coin in every iteration, this is not possible. And since the coins available are all multiples of each other, it means that summing combinations of smaller coins together will not be able to be replaced by a bigger coin. This means that the greedy set is the optimal set. \\\\
        If the algorithm is always correct and optimal, then it correctly returns the minimum number of coins to pay $n$ for any  given $n \ge 1$.
        \newpage 
        \item \textbf{(10 Points)} In Dystopia, instead of $\{\$1, \$5, \$10, \$25,  \$100\}$, the coins have values $$\{\oplus 1, \oplus10, \oplus 21, \oplus 34, \oplus 70, \oplus 100, \oplus 350, \oplus 1225, \oplus 1500\}.$$ Does the Cashier Exchange algorithm also work correctly in Dystopia? If yes, prove it. If no, provide an example where the Cashier Exchange algorithm does not return the minimum number of coins for a given amount in Dystopia. \\\\
        \textbf{Counter Example:} $74$ \\
        Using a greedy algorithm, it will yield a set $S = [70, 1, 1, 1, 1]$ \\
        However, the optimal solution would be a set $OPT = [34, 34]$
    \end{enumerate}

\newpage

\begin{prob}{(
25 points) Stabbing Intervals}\end{prob}

Let $X$ be a set of $n$ intervals on the real line. The input, for each $1 \leq i \leq n$, specifies the start value $s_i$ and the finish value $f_i$ of interval $i$. We say that a set $P$ of points stabs $X$ if every interval in $X$ contains at least one point in $P$. Describe and analyze an efficient algorithm to compute the smallest set of points that stabs $X$. As usual, If you use a greedy algorithm, you must prove that it is correct.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{figs/stab.png}
\end{figure}
\begin{enumerate}
  \item Sort $X$ by finish times
  \item Initialize list $P$
  \item Add the finish time of the first element in $X$ to $P$
  \item Iterate through $X$
  \item If last element of $P$ is not in the interval of current element \\
  Add the finish time of the current element to $P$
  \item Return $P$
\end{enumerate}
Sorting $X$ would be $O(n \log n)$ which would dominate the iteration as iterating through $X$ would be $O(n)$ and comparisons would be $O(1)$ making the greedy algorithm $O(n \log n)$. The space complexity would just be the size of $P$ which we'll call $O(n)$ as in the worst-case scenario you need a point for every single interval in $X$.\\\\
\textbf{Correctness:} If a correct set and the greedy set were to differ by a point, the algorithm deems this only if an existing point in $P$ already covers the intervals intersecting with that point. Therefore, the greedy algorithm is always correct. \\\\
\textbf{Optimality:} If the optimal set and the greedy set were to differ by a point, you could exchange the points at which they differ. The new greedy set would still stab all the needed intervals without increasing its size, thus making the greedy set an optimal solution.

\newpage

\begin{prob}
	(25 points) Covering Intervals
\end{prob}

Let $X$ be a set of $n$ intervals on the real line. The input, for each $1 \leq i \leq n$, specifies the start value $s_i$ and the finish value $f_i$ of interval $i$. We say that a subset of intervals $Y \subseteq X$ covers $X$ if the union of all intervals in $Y$ is equal to the union of all intervals in $X$ . The size of a cover is just the number of intervals. Describe and analyze an efficient algorithm to compute the smallest cover of $X$. If you use a greedy algorithm, you must prove that it is correct.

\begin{figure}[h]
     \centering
     \includegraphics[width=0.8\linewidth]{figs/covering.png}
 \end{figure}
\begin{enumerate}
    \item Sort $X$ by start times
    \item Initialize an empty list $C$
    \item Initialize a variable $max\_end$ to the lowest start time in $X$
    \item Iterate through the sorted list
    \item Get $a \in X \left\{ s_a \leq max\_end \right\}$ with largest $f_a$
    \item Add $a$ to $C$
    \item $max\_end \gets f_a$
    \item Repeat this process until last item of $C$ has a $f_i$ that is equal to the latest finish time in $X$
\end{enumerate}
Sorting $X$ would be $O(n \log n)$. The iteration through $X$ would be $O(n)$ and comparisons to find a max range would be $O(n)$. This makes the algorithm dominated by $O(n^{2})$. The space complexity would be the size of $C$ which is $O(n)$ in the worst case that the cover comprises of every interval in $X$. \\\\
\textbf{Correctness:} Since the process by which it chooses initializes with the lowest start time and continues until the latest finish time is covered, the algorithm is always producing a suitable cover for the intervals. \\\\
\textbf{Optimality:} If the optimal set and the greedy set were to differ at any interval, you could exchange the intervals at which they differ. Since the greedy algorithm chooses by covering the biggest interval possible at every choice, the new greedy set will still cover the entire interval without increasing in size, thus making the greedy set an optimal solution.
\end{document}